{"name":"Synapse","tagline":"Config at your own taste","body":"##  Installation / compatibility\r\n\r\n[**Download on the Play Store**](https://play.google.com/store/apps/details?id=com.af.synapse)\r\n\r\nDiscussions maybe be held or questions asked here: \r\n\r\n* [Google+ community](https://plus.google.com/communities/108137360526908770337)\r\n\r\n### Initialization\r\n\r\n* Synapse expects a `su` program in the environment PATH to execute.\r\n* Synapse expects a `uci` program in the environment PATH to execute.\r\n\r\n`uci` is expected to serve two possible parameters in its first parameter position;\r\n\r\n* `uci config` which will return via standard output a JSON formatted configuration output representing the element domain model.\r\n* `uci actionpath` which will return via standard output a plaintext absolute path to the folder containing the helper executables.\r\n\r\nThe `uci` back-end serves as the configuration to the application, declaring the interface elements and actions available to it. The location of the executable doesn't matter to the app as long as it has access to it via PATH. \r\n\r\nThe actionpath serves as a second-order executable environment that is internally used on top of PATH (it is just exported to PATH in the internal command shells). Its purpose is to facilitate separation of helper executables from other system executables. The actionpath is given the highest execution priority, above `/sbin`.\r\n\r\nThe common implementation is to include it into the ramdisk of a kernel: this method allows binding of the controls to a specific kernel image. Optionally, it can be injected anywhere else such as the system partition and symlinked to `/xbin` or `/bin`. The latter requires that the domain model (uci config) be perpetually dynamic to avoid conflicts caused by differing kernel or OS versions.\r\n\r\n### Actions\r\n\r\nAn action is any executable found in the location provided by `uci actionpath` or in the common executable environments provided by PATH.\r\n\r\nAn action is expected to be in itself a unique identifier inside the domain model of the application.\r\n\r\nParameters may be concatenated to the action's executable name; the resulting string is an element's action.\r\n\r\nExample: `generic /sys/block/mmcblk0/queue/read_ahead_kb` defines an action to the `generic` executable and always passes `/sys/block/mmcblk0/queue/read_ahead_kb` as its first parameter.\r\n\r\nAction executables are expected to have two modes of functioning:\r\n* Read-mode; The action is executed without any additional parameters, and is expected to return via standard output an _action-value_.\r\n* Write-mode; The action is executed with an additional parameter representing an _action-value_, and is expected to return via standard output an _action-value_.\r\n\r\nAn _action-value_ is an arbitrary value of undefined type and length, terminated by a `\\n` newline character.\r\n\r\nThe application remembers and saves action-values on a key-value basis, where the key is the unique identifier provided by the action itself. They are stored internally in a database in the system's application data under `com.af.synapse/databases/actionValueStore`.\r\n\r\nExample: `generic`\r\n```sh\r\nif [ -f $1 ];then\r\n\tif [[ ! -z $2 ]]; then\r\n\t\techo $2 > $1\r\n\tfi\r\n\r\n\techo `cat $1`\r\nfi\r\n```\r\nThe above action executable takes a file path and returns its contents. If an action-value is passed on, the action-value is forwarded to the standard input of the given file path.\r\n\r\nIn the case of `generic /sys/block/mmcblk0/queue/read_ahead_kb`, it will read out the file and output it via standard output, or pipe the given parameter into the file's standard input and then read out the file to standard output.\r\n\r\nThe point of actions are that they be used as configurable and dynamic translation layers which provide large amount of flexibility.\r\n\r\nAdvanced example: `colour`\r\n```sh\r\nif [[ ! -z $2 ]]; then\r\n\tlet \"RC=($((16$2)) & 16711680) >> 16\";\r\n\tlet \"GC=($((16$2)) & 65280) >> 8\";\r\n\tlet \"BC=$((16$2)) & 255\";\r\nfi\r\n\r\ncase $1 in\r\n\r\nscr_red)\t;&\r\nscr_green)\t;&\r\nscr_blue)\t;&\r\nscr_yellow)\t;&\r\nscr_cyan)\t;&\r\nscr_magenta)\t;&\r\nscr_white)\t;&\r\nscr_black)\r\n\tP=/sys/class/misc/mdnie/hook_control/\r\n\r\n\tif [[ ! -z $2 ]]; then\r\n\t\techo $RC > $P/$1_red\r\n\t\techo $GC > $P/$1_green\r\n\t\techo $BC > $P/$1_blue\r\n\tfi\r\n\r\n\techo $(printf \"#%02X%02X%02X\\n\" $(cat $P/$1_red) $(cat $P/$1_green) $(cat $P/$1_blue))\r\n\t;;\r\nesac\r\n```\r\nThe above translates a hexadecimal representation of a colour to, and from three sysfs nodes representing each component in decimal.\r\n\r\n### JSON domain model\r\n\r\n`uci config`, as mentioned, is expected to output a JSON formatted domain model of the interface elements.\r\n\r\nThe root structure is:\r\n```json\r\n{\r\n    \"sections\": [\r\n     ....\r\n    ]\r\n}\r\n```\r\n\r\nThe root object contains a `sections` name/value pair whose value is an array of objects representing sections.\r\n\r\nA section is defined as:\r\n```json\r\n{\r\n    \"name\":\"Section name example\",\r\n    \"elements\":[\r\n      ....\r\n    ]\r\n} \r\n```\r\nSection names can also be localised:\r\n```json\r\n{\r\n    \"name\":{ \"en\":\"Section name example\", \"fr\":\"Nom de section exemplaire\" },\r\n    \"elements\":[\r\n      ....\r\n    ]\r\n} \r\n```\r\n\r\nA section contains a `name` key with the name of the section as its value, and an `elements` key with an array of objects as its values.\r\n\r\n**NOTE:** The parser accepts non-strictly formatted JSON as input, such that structures as the following are still correctly interpreted:\r\n```json\r\n{\r\n    name:MySection,\r\n    elements: [\r\n      ....\r\n    ]\r\n}\r\n```\r\n\r\nEach element represents a View inside the LinearLayout of a section.\r\n\r\n### Localisation\r\n\r\nLocalisation is supported on the element level. Any string-based interface elements can be localised.\r\n\r\nWhere a non-localised element string would look as follows:\r\n```javascript\r\n    description:\"This is your desired default description language-independent\"\r\n```\r\nA localised one would look as follows:\r\n```javascript\r\n    description:{\r\n       en:\"This is your desired English language localisation and also fall-back localisation.\",\r\n       fr:\"This is your French language localisation\",\r\n       es:\"This is your Spanish language localisation\"\r\n    }\r\n```\r\nIf your device is currently set to a country-specific locale such as `es_ES` for the Spain locale, if a `es_ES` locale is not specifically defined, the application will try to fall back to a general language locale. In the above case `es_ES` and `es_US` or any other regional locale of Spanish will fall back to `es`. Localisation codes are standard Java defines, [as listed here](http://www.oracle.com/technetwork/java/javase/javase7locales-334809.html), but also highly depend on the ROM.\r\n\r\n\r\nFor a listing of available elements and their JSON notations please read:\r\n###[Element listing and documentation](https://github.com/AndreiLux/Synapse/wiki/Element-listing-and-documentation)\r\n\r\nA fully valid domain model can be now built given the previous described elements:\r\n```javascript\r\n{\r\n   sections:[\r\n      {\r\n         name:CPU,\r\n         elements:[\r\n            {\r\n               STitleBar:{\r\n                  title:\"CPUFreq scaling\"\r\n               }\r\n            },\r\n            {\r\n               SSeekBar:{\r\n                  title:\"CPU max frequency\",\r\n                  description:\"Set the maximum freqency the CPU scales up to.\",\r\n                  unit:\"MHz\",\r\n                  step:100000,\r\n                  weight:0.001,\r\n                  min:100000,\r\n                  max:2000000,\r\n                  default:1600000,\r\n                  action:\"generic /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq\"\r\n               }\r\n            },\r\n         ]\r\n      },\r\n      {\r\n         name:GPU,\r\n         elements:[\r\n            {\r\n               SPane:{\r\n                  title:\"GPU scaling settings\",\r\n                  description:\"By editing the following configurables you can change the performance behaviour of the GPU.\"\r\n               }\r\n            },\r\n            {\r\n               SOptionList:{\r\n                  title:\"GPU max freq\",\r\n                  description:\"Set the maximum freqency the GPU scales up to.\",\r\n                  default:480,\r\n                  unit:\"MHz\",\r\n                  action:\"generic /sys/devices/platform/pvrsrvkm.0/sgx_dvfs_max_lock\",\r\n                  values:[\r\n                     700,\r\n                     640,\r\n                     600,\r\n                     532,\r\n                     480,\r\n                     350,\r\n                     266,\r\n                     177,\r\n                  ]\r\n               }\r\n            },\r\n         ]\r\n      }\r\n   ]\r\n}\r\n```\r\n\r\nThe domain models can be extended in breadth with no limit. [Here is an example of a 7-section model with over 150 elements.](https://gist.github.com/AndreiLux/6702092)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}